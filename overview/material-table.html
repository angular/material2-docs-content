<html><head></head><body><div class="docs-markdown"><p class="docs-markdown-p">The <code class="docs-markdown-code">mat-table</code> provides a Material Design styled data-table that can be used to display rows of data.</p><p class="docs-markdown-p">This table builds on the foundation of the CDK data-table and uses a similar interface for its data input and template, except that its element and attribute selectors will be prefixed with <code class="docs-markdown-code">mat-</code> instead of <code class="docs-markdown-code">cdk-</code>. For more information on the interface and a detailed look at how the table is implemented, see the <a href="https://material.angular.io/guide/cdk-table" class="docs-markdown-a">guide covering the CDK data-table</a>.</p><h3 id="getting-started" class="docs-header-link docs-markdown-h3"><span header-link="getting-started"></span> Getting Started</h3><div material-docs-example="table-basic"></div><h4 id="1-write-your-mat-table-and-provide-data" class="docs-header-link docs-markdown-h4"><span header-link="1-write-your-mat-table-and-provide-data"></span> 1. Write your mat-table and provide data</h4><p class="docs-markdown-p">Begin by adding the <code class="docs-markdown-code">&lt;table mat-table&gt;</code> component to your template and passing in data.</p><p class="docs-markdown-p">The simplest way to provide data to the table is by passing a data array to the table's <code class="docs-markdown-code">dataSource</code> input. The table will take the array and render a row for each object in the data array.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">mat-table</span> [<span class="hljs-attr">dataSource</span>]=<span class="hljs-string">”myDataArray”</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
</code></pre><p class="docs-markdown-p">Since the table optimizes for performance, it will not automatically check for changes to the data array. Instead, when objects are added, removed, or moved on the data array, you can trigger an update to the table's rendered rows by calling its <code class="docs-markdown-code">renderRows()</code> method.</p><p class="docs-markdown-p">While an array is the <em>simplest</em> way to bind data into the data source, it is also the most limited. For more complex applications, using a <code class="docs-markdown-code">DataSource</code> instance is recommended. See the section "Advanced data sources" below for more information.</p><h4 id="2-define-the-column-templates" class="docs-header-link docs-markdown-h4"><span header-link="2-define-the-column-templates"></span> 2. Define the column templates</h4><p class="docs-markdown-p">Next, write your table's column templates.</p><p class="docs-markdown-p">Each column definition should be given a unique name and contain the content for its header and row cells.</p><p class="docs-markdown-p">Here's a simple column definition with the name <code class="docs-markdown-code">'userName'</code>. The header cell contains the text "Name" and each row cell will render the <code class="docs-markdown-code">name</code> property of each row's data.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"userName"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> Name <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let user"</span>&gt;</span> {{user.name}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre><h4 id="3-define-the-row-templates" class="docs-header-link docs-markdown-h4"><span header-link="3-define-the-row-templates"></span> 3. Define the row templates</h4><p class="docs-markdown-p">Finally, once you have defined your columns, you need to tell the table which columns will be rendered in the header and data rows.</p><p class="docs-markdown-p">To start, create a variable in your component that contains the list of the columns you want to render.</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code">columnsToDisplay = [<span class="hljs-string">'userName'</span>, <span class="hljs-string">'age'</span>];
</code></pre><p class="docs-markdown-p">Then add <code class="docs-markdown-code">mat-header-row</code> and <code class="docs-markdown-code">mat-row</code> to the content of your <code class="docs-markdown-code">mat-table</code> and provide your column list as inputs.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-header-row</span> *<span class="hljs-attr">matHeaderRowDef</span>=<span class="hljs-string">"columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-row</span> *<span class="hljs-attr">matRowDef</span>=<span class="hljs-string">"let myRowData; columns: columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre><p class="docs-markdown-p">Note that this list of columns provided to the rows can be in any order, not necessary the order in which you wrote the column definitions. Also, you do not necessarily have to include every column that was defined in your template.</p><p class="docs-markdown-p">This means that by changing your column list provided to the rows, you can easily re-order and include/exclude columns dynamically.</p><h3 id="advanced-data-sources" class="docs-header-link docs-markdown-h3"><span header-link="advanced-data-sources"></span> Advanced data sources</h3><p class="docs-markdown-p">The simplest way to provide data to your table is by passing a data array. More complex use-cases may benefit from a more flexible approach involving an Observable stream or by encapsulating your data source logic into a <code class="docs-markdown-code">DataSource</code> class.</p><h4 id="observable-stream-of-data-arrays" class="docs-header-link docs-markdown-h4"><span header-link="observable-stream-of-data-arrays"></span> Observable stream of data arrays</h4><p class="docs-markdown-p">An alternative approach to providing data to the table is by passing an Observable stream that emits the data array to be rendered each time it is changed. The table will listen to this stream and automatically trigger an update to the rows each time a new data array is emitted.</p><h4 id="datasource" class="docs-header-link docs-markdown-h4"><span header-link="datasource"></span> DataSource</h4><p class="docs-markdown-p">For most real-world applications, providing the table a DataSource instance will be the best way to manage data. The DataSource is meant to serve a place to encapsulate any sorting, filtering, pagination, and data retrieval logic specific to the application.</p><p class="docs-markdown-p">A DataSource is simply a base class that has two functions: <code class="docs-markdown-code">connect</code> and <code class="docs-markdown-code">disconnect</code>. The <code class="docs-markdown-code">connect</code> function will be called by the table to receive a stream that emits the data array that should be rendered. The table will call <code class="docs-markdown-code">disconnect</code> when the table is destroyed, which may be the right time to clean up any subscriptions that may have been registered during the connect process.</p><h3 id="features" class="docs-header-link docs-markdown-h3"><span header-link="features"></span> Features</h3><p class="docs-markdown-p">The <code class="docs-markdown-code">MatTable</code> is focused on a single responsibility: efficiently render rows of data in a performant and accessible way.</p><p class="docs-markdown-p">You'll notice that the table itself doesn't come out of the box with a lot of features, but expects that the table will be included in a composition of components that fills out its features.</p><p class="docs-markdown-p">For example, you can add sorting and pagination to the table by using MatSort and MatPaginator and mutating the data provided to the table according to their outputs.</p><p class="docs-markdown-p">To simplify the use case of having a table that can sort, paginate, and filter an array of data, the Angular Material library comes with a <code class="docs-markdown-code">MatTableDataSource</code> that has already implemented the logic of determining what rows should be rendered according to the current table state. To add these feature to the table, check out their respective sections below.</p><h4 id="pagination" class="docs-header-link docs-markdown-h4"><span header-link="pagination"></span> Pagination</h4><p class="docs-markdown-p">To paginate the table's data, add a <code class="docs-markdown-code">&lt;mat-paginator&gt;</code> after the table.</p><p class="docs-markdown-p">If you are using the <code class="docs-markdown-code">MatTableDataSource</code> for your table's data source, simply provide the <code class="docs-markdown-code">MatPaginator</code> to your data source. It will automatically listen for page changes made by the user and send the right paged data to the table.</p><p class="docs-markdown-p">Otherwise if you are implementing the logic to paginate your data, you will want to listen to the paginator's <code class="docs-markdown-code">(page)</code> output and pass the right slice of data to your table.</p><p class="docs-markdown-p">For more information on using and configuring the <code class="docs-markdown-code">&lt;mat-paginator&gt;</code>, check out the <a href="https://material.angular.io/components/paginator/overview" class="docs-markdown-a">mat-paginator docs</a>.</p><p class="docs-markdown-p">The <code class="docs-markdown-code">MatPaginator</code> is one provided solution to paginating your table's data, but it is not the only option. In fact, the table can work with any custom pagination UI or strategy since the <code class="docs-markdown-code">MatTable</code> and its interface is not tied to any one specific implementation.</p><div material-docs-example="table-pagination"></div><h4 id="sorting" class="docs-header-link docs-markdown-h4"><span header-link="sorting"></span> Sorting</h4><p class="docs-markdown-p">To add sorting behavior to the table, add the <code class="docs-markdown-code">matSort</code> directive to the table and add <code class="docs-markdown-code">mat-sort-header</code> to each column header cell that should trigger sorting.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-comment">&lt;!-- Name Column --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"position"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span> <span class="hljs-attr">mat-sort-header</span>&gt;</span> Name <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let element"</span>&gt;</span> {{element.position}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre><p class="docs-markdown-p">If you are using the <code class="docs-markdown-code">MatTableDataSource</code> for your table's data source, provide the <code class="docs-markdown-code">MatSort</code> directive to the data source and it will automatically listen for sorting changes and change the order of data rendered by the table.</p><p class="docs-markdown-p">By default, the <code class="docs-markdown-code">MatTableDataSource</code> sorts with the assumption that the sorted column's name matches the data property name that the column displays. For example, the following column definition is named <code class="docs-markdown-code">position</code>, which matches the name of the property displayed in the row cell.</p><p class="docs-markdown-p">Note that if the data properties do not match the column names, or if a more complex data property accessor is required, then a custom <code class="docs-markdown-code">sortingDataAccessor</code> function can be set to override the default data accessor on the <code class="docs-markdown-code">MatTableDataSource</code>.</p><p class="docs-markdown-p">If you are not using the <code class="docs-markdown-code">MatTableDataSource</code>, but instead implementing custom logic to sort your data, listen to the sort's <code class="docs-markdown-code">(matSortChange)</code> event and re-order your data according to the sort state. If you are providing a data array directly to the table, don't forget to call <code class="docs-markdown-code">renderRows()</code> on the table, since it will not automatically check the array for changes.</p><div material-docs-example="table-sorting"></div><p class="docs-markdown-p">For more information on using and configuring the sorting behavior, check out the <a href="https://material.angular.io/components/sort/overview" class="docs-markdown-a">matSort docs</a>.</p><p class="docs-markdown-p">The <code class="docs-markdown-code">MatSort</code> is one provided solution to sorting your table's data, but it is not the only option. In fact, the table can work with any custom pagination UI or strategy since the <code class="docs-markdown-code">MatTable</code> and its interface is not tied to any one specific implementation.</p><h4 id="filtering" class="docs-header-link docs-markdown-h4"><span header-link="filtering"></span> Filtering</h4><p class="docs-markdown-p">Angular Material does not provide a specific component to be used for filtering the <code class="docs-markdown-code">MatTable</code> since there is no single common approach to adding a filter UI to table data.</p><p class="docs-markdown-p">A general strategy is to add an input where users can type in a filter string and listen to this input to change what data is offered from the data source to the table.</p><p class="docs-markdown-p">If you are using the <code class="docs-markdown-code">MatTableDataSource</code>, simply provide the filter string to the<br><code class="docs-markdown-code">MatTableDataSource</code>. The data source will reduce each row data to a serialized form and will filter out the row if it does not contain the filter string. By default, the row data reducing function will concatenate all the object values and convert them to lowercase.</p><p class="docs-markdown-p">For example, the data object <code class="docs-markdown-code">{id: 123, name: 'Mr. Smith', favoriteColor: 'blue'}</code> will be reduced to <code class="docs-markdown-code">123mr. smithblue</code>. If your filter string was <code class="docs-markdown-code">blue</code> then it would be considered a match because it is contained in the reduced string, and the row would be displayed in the table.</p><p class="docs-markdown-p">To override the default filtering behavior, a custom <code class="docs-markdown-code">filterPredicate</code> function can be set which takes a data object and filter string and returns true if the data object is considered a match.</p><div material-docs-example="table-filtering"></div><h4 id="selection" class="docs-header-link docs-markdown-h4"><span header-link="selection"></span> Selection</h4><p class="docs-markdown-p">Right now there is no formal support for adding a selection UI to the table, but Angular Material does offer the right components and pieces to set this up. The following steps are one solution but it is not the only way to incorporate row selection in your table.</p><h5 class="docs-markdown-h5">1. Add a selection model</h5><p class="docs-markdown-p">Get started by setting up a <code class="docs-markdown-code">SelectionModel</code> from <code class="docs-markdown-code">@angular/cdk/collections</code> that will maintain the selection state.</p><pre class="docs-markdown-pre"><code class="lang-js docs-markdown-code"><span class="hljs-keyword">const</span> initialSelection = [];
<span class="hljs-keyword">const</span> allowMultiSelect = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">this</span>.selection = <span class="hljs-keyword">new</span> SelectionModel&lt;MyDataType&gt;(allowMultiSelect, initialSelection);
</code></pre><h5 class="docs-markdown-h5">2. Define a selection column</h5><p class="docs-markdown-p">Add a column definition for displaying the row checkboxes, including a master toggle checkbox for the header. The column name should be added to the list of displayed columns provided to the header and data row.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"select"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-checkbox</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"$event ? masterToggle() : null"</span>
                  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"selection.hasValue() &amp;&amp; isAllSelected()"</span>
                  [<span class="hljs-attr">indeterminate</span>]=<span class="hljs-string">"selection.hasValue() &amp;&amp; !isAllSelected()"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-checkbox</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-checkbox</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"$event.stopPropagation()"</span>
                  (<span class="hljs-attr">change</span>)=<span class="hljs-string">"$event ? selection.toggle(row) : null"</span>
                  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"selection.isSelected(row)"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-checkbox</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre><h5 class="docs-markdown-h5">3. Add event handling logic</h5><p class="docs-markdown-p">Implement the behavior in your component's logic to handle the header's master toggle and checking if all rows are selected.</p><pre class="docs-markdown-pre"><code class="lang-js docs-markdown-code"><span class="hljs-comment">/** Whether the number of selected elements matches the total number of rows. */</span>
isAllSelected() {
  <span class="hljs-keyword">const</span> numSelected = <span class="hljs-keyword">this</span>.selection.selected.length;
  <span class="hljs-keyword">const</span> numRows = <span class="hljs-keyword">this</span>.dataSource.data.length;
  <span class="hljs-keyword">return</span> numSelected == numRows;
}

<span class="hljs-comment">/** Selects all rows if they are not all selected; otherwise clear selection. */</span>
masterToggle() {
  <span class="hljs-keyword">this</span>.isAllSelected() ?
      <span class="hljs-keyword">this</span>.selection.clear() :
      <span class="hljs-keyword">this</span>.dataSource.data.forEach(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> <span class="hljs-keyword">this</span>.selection.select(row));
}
</code></pre><h4 id="footer-row" class="docs-header-link docs-markdown-h4"><span header-link="footer-row"></span> Footer row</h4><p class="docs-markdown-p">A footer row can be added to the table by adding a footer row definition to the table and adding footer cell templates to column definitions. The footer row will be rendered after the rendered data rows.</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"cost"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> Cost <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let data"</span>&gt;</span> {{data.cost}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-footer-cell</span> *<span class="hljs-attr">matFooterCellDef</span>&gt;</span> {{totalCost}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

...

<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-header-row</span> *<span class="hljs-attr">matHeaderRowDef</span>=<span class="hljs-string">"columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-row</span> *<span class="hljs-attr">matRowDef</span>=<span class="hljs-string">"let myRowData; columns: columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-footer-row</span> *<span class="hljs-attr">matFooterRowDef</span>=<span class="hljs-string">"columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span></span>
</code></pre><div material-docs-example="table-footer-row"></div><h5 class="docs-markdown-h5">4. Include overflow styling</h5><p class="docs-markdown-p">Finally, adjust the styling for the select column so that its overflow is not hidden. This allows the ripple effect to extend beyond the cell.</p><pre class="docs-markdown-pre"><code class="lang-css docs-markdown-code"><span class="hljs-selector-class">.mat-column-select</span> {
  <span class="hljs-attribute">overflow</span>: initial;
}
</code></pre><div material-docs-example="table-selection"></div><h3 id="accessibility" class="docs-header-link docs-markdown-h3"><span header-link="accessibility"></span> Accessibility</h3><p class="docs-markdown-p">Tables without text or labels should be given a meaningful label via <code class="docs-markdown-code">aria-label</code> or <code class="docs-markdown-code">aria-labelledby</code>. The <code class="docs-markdown-code">aria-readonly</code> defaults to <code class="docs-markdown-code">true</code> if it's not set.</p><p class="docs-markdown-p">Table's default role is <code class="docs-markdown-code">grid</code>, and it can be changed to <code class="docs-markdown-code">treegrid</code> through <code class="docs-markdown-code">role</code> attribute.</p><p class="docs-markdown-p"><code class="docs-markdown-code">mat-table</code> does not manage any focus/keyboard interaction on its own. Users can add desired focus/keyboard interactions in their application.</p><h3 id="tables-with-code-display-flex-code-" class="docs-header-link docs-markdown-h3"><span header-link="tables-with-code-display-flex-code-"></span> Tables with <code class="docs-markdown-code">display: flex</code></h3><p class="docs-markdown-p">The <code class="docs-markdown-code">MatTable</code> does not require that you use a native HTML table. Instead, you can use an alternative approach that uses <code class="docs-markdown-code">display: flex</code> for the table's styles.</p><p class="docs-markdown-p">This alternative approach replaces the native table element tags with the <code class="docs-markdown-code">MatTable</code> directive selectors. For example, <code class="docs-markdown-code">&lt;table mat-table&gt;</code> becomes <code class="docs-markdown-code">&lt;mat-table&gt;</code>; <code class="docs-markdown-code">&lt;tr mat-row</code>&gt; becomes <code class="docs-markdown-code">&lt;mat-row&gt;</code>. The following shows a previous example using this alternative template:</p><pre class="docs-markdown-pre"><code class="lang-html docs-markdown-code"><span class="hljs-tag">&lt;<span class="hljs-name">mat-table</span> [<span class="hljs-attr">dataSource</span>]=<span class="hljs-string">"dataSource"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- User name Definition --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">cdkColumnDef</span>=<span class="hljs-string">"username"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-cell</span> *<span class="hljs-attr">cdkHeaderCellDef</span>&gt;</span> User name <span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-cell</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-cell</span> *<span class="hljs-attr">cdkCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> {{row.username}} <span class="hljs-tag">&lt;/<span class="hljs-name">mat-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Age Definition --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">cdkColumnDef</span>=<span class="hljs-string">"age"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-cell</span> *<span class="hljs-attr">cdkHeaderCellDef</span>&gt;</span> Age <span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-cell</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-cell</span> *<span class="hljs-attr">cdkCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> {{row.age}} <span class="hljs-tag">&lt;/<span class="hljs-name">mat-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Title Definition --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">cdkColumnDef</span>=<span class="hljs-string">"title"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-cell</span> *<span class="hljs-attr">cdkHeaderCellDef</span>&gt;</span> Title <span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-cell</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-cell</span> *<span class="hljs-attr">cdkCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> {{row.title}} <span class="hljs-tag">&lt;/<span class="hljs-name">mat-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Header and Row Declarations --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-row</span> *<span class="hljs-attr">cdkHeaderRowDef</span>=<span class="hljs-string">"['username', 'age', 'title']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-row</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-row</span> *<span class="hljs-attr">cdkRowDef</span>=<span class="hljs-string">"let row; columns: ['username', 'age', 'title']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-row</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-table</span>&gt;</span>
</code></pre><p class="docs-markdown-p">Note that this approach means you cannot include certain native-table features such colspan/rowspan or have columns that resize themselves based on their content.</p><h3 id="applying-material-styles-to-native-table" class="docs-header-link docs-markdown-h3"><span header-link="applying-material-styles-to-native-table"></span> Applying material styles to native table</h3><p class="docs-markdown-p">If you want to have a Material design styled <code class="docs-markdown-code">&lt;table&gt;</code> without using the <code class="docs-markdown-code">MatTable</code>, simply apply the appropriate classes to the table elements. This may be useful if you have an existing table or if you do not need the additional benefits and features of the <code class="docs-markdown-code">MatTable</code>.</p><div material-docs-example="table-native-only"></div></div></body></html>