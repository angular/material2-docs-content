<div class="docs-markdown"><p><code>@angular/cdk/testing</code> provides infrastructure to help with testing Angular components.</p>

        <h3 id="component-test-harnesses" class="docs-header-link">
          <span header-link="component-test-harnesses"></span>
          Component test harnesses
        </h3>
      <p>A component harness is a class that lets a test interact with a component via a supported API.
Each harness&#39;s API interacts with a component the same way a user would. By using the harness API,
a test insulates itself against updates to the internals of a component, such as changing its DOM
structure. The idea for component harnesses comes from the
<a href="https://martinfowler.com/bliki/PageObject.html">PageObject</a> pattern commonly used for integration
testing.</p>
<p><code>@angular/cdk/testing</code> contains infrastructure for creating and using component test harnesses. You
can create test harnesses for any component, ranging from small reusable widgets to full application
pages.</p>
<p>The component harness system supports multiple testing environments. You can use the same harness
implementation in both unit and end-to-end tests. This means that users only need to learn one API,
and component authors don&#39;t have to maintain separate unit and end-to-end test implementations.</p>
<p>Common component libraries, in particular, benefit from this infrastructure due to the wide use of
their components. Providing a test harness allows the consumers of a component to write tests that
avoid dependencies on any private implementation details. By capturing these implementation details
in a single place, consumers can more easily update to new library versions.</p>
<p>This document provides guidance for three types of developers:</p>
<ol>
<li><a href="#api-for-test-authors">Test authors</a></li>
<li><a href="#api-for-component-harness-authors">Component harness authors</a></li>
<li><a href="#api-for-harness-environment-authors">Harness environment authors</a></li>
</ol>
<p>Since many developers fall into only one of these categories, the relevant APIs are broken out by
developer type in the sections below.</p>

        <h3 id="api-for-test-authors" class="docs-header-link">
          <span header-link="api-for-test-authors"></span>
          API for test authors
        </h3>
      <p>Test authors are developers using component harnesses written by someone else to test their
application. For example, this could be an app developer who uses a third-party menu component and
needs to interact with the menu in a unit test.</p>

        <h4 id="working-with-componentharness-classes" class="docs-header-link">
          <span header-link="working-with-componentharness-classes"></span>
          Working with <code>ComponentHarness</code> classes
        </h4>
      <p><code>ComponentHarness</code> is the abstract base class for all component harnesses. Every harness extends
this class. All <code>ComponentHarness</code> subclasses have a static property, <code>hostSelector</code>, that
matches the harness class to instances of the component in the DOM. Beyond that, the API of any
given harness is specific to its corresponding component; refer to the component&#39;s documentation to
learn how to use a specific harness.</p>

        <h4 id="using-testbedharnessenvironment-and-seleniumwebdriverharnessenvironment" class="docs-header-link">
          <span header-link="using-testbedharnessenvironment-and-seleniumwebdriverharnessenvironment"></span>
          Using <code>TestbedHarnessEnvironment</code> and <code>SeleniumWebDriverHarnessEnvironment</code>
        </h4>
      <p>These classes correspond to different implementations of the component harness system with bindings
for specific test environments. Any given test must only import <em>one</em> of these classes. Karma-based
unit tests should use the <code>TestbedHarnessEnvironment</code>, while Selenium WebDriver-based end-to-end tests
should use the <code>SeleniumWebDriverHarnessEnvironment</code>. Additional environments require custom bindings; see
<a href="#api-for-harness-environment-authors">API for harness environment authors</a> for more information on
alternate test environments.</p>
<p>These classes are primarily used to create a <code>HarnessLoader</code> instance, and in certain cases, to
create <code>ComponentHarness</code> instances directly.</p>
<p><code>TestbedHarnessEnvironment</code> offers the following static methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>loader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td>Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the fixture&#39;s root element. Should be used to create harnesses for elements contained inside the fixture</td>
</tr>
<tr>
<td><code>documentRootLoader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td>Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the HTML document&#39;s root element. Can be used to create harnesses for elements that fall outside of the fixture</td>
</tr>
<tr>
<td><code>harnessForFixture&lt;T extends ComponentHarness&gt;(fixture: ComponentFixture&lt;unknown&gt;, harnessType: ComponentHarnessConstructor&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td>Used to create a <code>ComponentHarness</code> instance for the fixture&#39;s root element directly. This is necessary when bootstrapping the test with the component you plan to load a harness for, because Angular does not set the proper tag name when creating the fixture.</td>
</tr>
</tbody></table>
<p>In most cases, you can create a <code>HarnessLoader</code> in the <code>beforeEach</code> block using
<code>TestbedHarnessEnvironment.loader(fixture)</code> and then use that <code>HarnessLoader</code> to create any
necessary <code>ComponentHarness</code> instances. The other methods cover special cases as shown in this
example:</p>
<p>Consider a reusable dialog-button component that opens a dialog on click, containing the following
components, each with a corresponding harness:</p>
<ul>
<li><code>MyDialogButton</code> (composes the <code>MyButton</code> and <code>MyDialog</code> with a convenient API)</li>
<li><code>MyButton</code> (a simple button component)</li>
<li><code>MyDialog</code> (a dialog appended to <code>document.body</code> by <code>MyDialogButton</code> upon click)</li>
</ul>
<p>The following code loads harnesses for each of these components:</p>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;MyDialogButton&gt;;
<span class="hljs-keyword">let</span> loader: HarnessLoader;
<span class="hljs-keyword">let</span> rootLoader: HarnessLoader;

beforeEach(<span class="hljs-function">() =&gt;</span> {
  fixture = TestBed.createComponent(MyDialogButton);
  loader = TestbedHarnessEnvironment.loader(fixture);
  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);
});

it(<span class="hljs-string">&#x27;loads harnesses&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// Load a harness for the bootstrapped component with `harnessForFixture`</span>
  dialogButtonHarness =
      <span class="hljs-keyword">await</span> TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);

  <span class="hljs-comment">// The button element is inside the fixture&#x27;s root element, so we use `loader`.</span>
  <span class="hljs-keyword">const</span> buttonHarness = <span class="hljs-keyword">await</span> loader.getHarness(MyButtonHarness);

  <span class="hljs-comment">// Click the button to open the dialog</span>
  <span class="hljs-keyword">await</span> buttonHarness.click();

  <span class="hljs-comment">// The dialog is appended to `document.body`, outside of the fixture&#x27;s root element,</span>
  <span class="hljs-comment">// so we use `rootLoader` in this case.</span>
  <span class="hljs-keyword">const</span> dialogHarness = <span class="hljs-keyword">await</span> rootLoader.getHarness(MyDialogHarness);

  <span class="hljs-comment">// ... make some assertions</span>
});
</code></pre>
<p><code>SeleniumWebDriverHarnessEnvironment</code> has an API that offers a single static method:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>loader(): HarnessLoader</code></td>
<td>Gets a <code>HarnessLoader</code> instance for the current HTML document, rooted at the document&#39;s root element.</td>
</tr>
</tbody></table>
<p>Since Selenium WebDriver does not deal with fixtures, the API in this environment is simpler. The
<code>HarnessLoader</code> returned by the <code>loader()</code> method should be sufficient for loading all necessary
<code>ComponentHarness</code> instances.</p>
<p>Please note that harnesses may not behave <em>exactly</em> the same in all environments. There will always
be some difference between the real browser-generated event sequence when a user clicks or types in
an element, versus the simulated event sequence generated in unit tests. Instead, the CDK makes a
best effort to normalize the behavior and simulate the most important events in the sequence.</p>

        <h4 id="creating-harnesses-with-harnessloader" class="docs-header-link">
          <span header-link="creating-harnesses-with-harnessloader"></span>
          Creating harnesses with <code>HarnessLoader</code>
        </h4>
      <p>Instances of this class correspond to a specific DOM element (the &quot;root element&quot; of the loader) and
are used to create <code>ComponentHarness</code> instances for elements under this root element.</p>
<p><code>HarnessLoader</code> instances have the following methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>getChildLoader(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td>Searches for an element matching the given selector below the root element of this <code>HarnessLoader</code>, and returns a new <code>HarnessLoader</code> rooted at the first matching element</td>
</tr>
<tr>
<td><code>getAllChildLoaders(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td>Acts like <code>getChildLoader</code>, but returns an array of <code>HarnessLoader</code> instances, one for each matching element, rather than just the first matching element</td>
</tr>
<tr>
<td><code>getHarness&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; | HarnessPredicate&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td>Searches for an instance of the given <code>ComponentHarness</code> class or <code>HarnessPredicate</code> below the root element of this <code>HarnessLoader</code> and returns an instance of the harness corresponding to the first matching element</td>
</tr>
<tr>
<td><code>getAllHarnesses&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; | HarnessPredicate&lt;T&gt;): Promise&lt;T[]&gt;</code></td>
<td>Acts like <code>getHarness</code>, but returns an array of harness instances, one for each matching element, rather than just the first matching element</td>
</tr>
</tbody></table>
<p>Calls to <code>getHarness</code> and <code>getAllHarnesses</code> can either take <code>ComponentHarness</code> subclass or a
<code>HarnessPredicate</code>. <code>HarnessPredicate</code> applies additional restrictions to the search (e.g. searching
for a button that has some particular text, etc). The
<a href="#filtering-harness-instances-with-harnesspredicate">details of <code>HarnessPredicate</code></a> are discussed in
the <a href="#api-for-component-harness-authors">API for component harness authors</a>; harness authors should
provide convenience methods on their <code>ComponentHarness</code> subclass to facilitate the creation of
<code>HarnessPredicate</code> instances. However, if the harness author&#39;s API is not sufficient, they can be
created manually.</p>

        <h4 id="change-detection" class="docs-header-link">
          <span header-link="change-detection"></span>
          Change detection
        </h4>
      <p>By default, test harnesses will run Angular&#39;s change detection before reading the state of a DOM
element and after interacting with a DOM element. While convenient in most cases, there may be times
that you need finer-grained control over change detection. For example, you may want to check the
state of a component while an async operation is pending. In these cases you can use the
<code>manualChangeDetection</code> function to disable automatic handling of change detection for a block of
code. For example:</p>
<pre><code class="language-ts">it(<span class="hljs-string">&#x27;checks state while async action is in progress&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> buttonHarness = loader.getHarness(MyButtonHarness);
  <span class="hljs-keyword">await</span> manualChangeDetection(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> buttonHarness.click();
    fixture.detectChanges();
    <span class="hljs-comment">// Check expectations while async click operation is in progress.</span>
    expect(isProgressSpinnerVisible()).toBe(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">await</span> fixture.whenStable();
    <span class="hljs-comment">// Check expectations after async click operation complete.</span>
    expect(isProgressSpinnerVisible()).toBe(<span class="hljs-literal">false</span>);
  });
});
</code></pre>

        <h4 id="working-with-asynchronous-component-harness-methods" class="docs-header-link">
          <span header-link="working-with-asynchronous-component-harness-methods"></span>
          Working with asynchronous component harness methods
        </h4>
      <p>To support both unit and end-to-end tests, and to insulate tests against changes in
asynchronous behavior, almost all harness methods are asynchronous and return a <code>Promise</code>;
therefore, the Angular team recommends using
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 <code>async</code>/<code>await</code> syntax</a>
to improve the test readability.</p>
<p>Note that <code>await</code> statements block the execution of your test until the associated <code>Promise</code>
resolves. Occasionally, you may want to perform multiple actions simultaneously and wait until
they&#39;re all done rather than performing each action sequentially. For example, reading multiple
properties off a single component. In these situations use the <code>parallel</code> function to parallelize
the operations. The parallel function works similarly to <code>Promise.all</code>, while also optimizing change
detection, so it is not run an excessive number of times. The following code demonstrates how you
can read multiple properties from a harness with <code>parallel</code>:</p>
<pre><code class="language-ts">it(<span class="hljs-string">&#x27;reads properties in parallel&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> checkboxHarness = loader.getHarness(MyCheckboxHarness);
  <span class="hljs-comment">// Read the checked and intermediate properties simultaneously.</span>
  <span class="hljs-keyword">const</span> [checked, indeterminate] = <span class="hljs-keyword">await</span> parallel(<span class="hljs-function">() =&gt;</span> [
    checkboxHarness.isChecked(),
    checkboxHarness.isIndeterminate()
  ]);
  expect(checked).toBe(<span class="hljs-literal">false</span>);
  expect(indeterminate).toBe(<span class="hljs-literal">true</span>);
});
</code></pre>

        <h3 id="api-for-component-harness-authors" class="docs-header-link">
          <span header-link="api-for-component-harness-authors"></span>
          API for component harness authors
        </h3>
      <p>Component harness authors are developers who maintain some reusable Angular component, and want to
create a test harness for it, that users of the component can use in their tests. For example, this
could be an author of a third party Angular component library or a developer who maintains a set of
common components for a large Angular application.</p>

        <h4 id="extending-componentharness" class="docs-header-link">
          <span header-link="extending-componentharness"></span>
          Extending <code>ComponentHarness</code>
        </h4>
      <p>The abstract <code>ComponentHarness</code> class is the base class for all component harnesses. To create a
custom component harness, extend <code>ComponentHarness</code> and implement the static property
<code>hostSelector</code>. The <code>hostSelector</code> property identifies elements in the DOM that match this harness
subclass. In most cases, the <code>hostSelector</code> should be the same as the <code>selector</code> of the corresponding
<code>Component</code> or <code>Directive</code>. For example, consider a simple popup component:</p>
<pre><code class="language-ts"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;my-popup&#x27;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button (click)=&quot;toggle()&quot;&gt;{{triggerText}}&lt;/button&gt;
    &lt;div *ngIf=&quot;open&quot; class=&quot;my-popup-content&quot;&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt;
  `</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopup</span> </span>{
  <span class="hljs-meta">@Input</span>() triggerText: <span class="hljs-built_in">string</span>;

  open = <span class="hljs-literal">false</span>;

  <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.open = !<span class="hljs-built_in">this</span>.open;
  }
}
</code></pre>
<p>In this case, a minimal harness for the component would look like the following:</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-popup&#x27;</span>;
}
</code></pre>
<p>While <code>ComponentHarness</code> subclasses require only the <code>hostSelector</code> property, most harnesses should
also implement a static <code>with</code> method to generate <code>HarnessPredicate</code> instances. The
<a href="#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> section below covers this
in more detail.</p>

        <h4 id="finding-elements-in-the-components-dom" class="docs-header-link">
          <span header-link="finding-elements-in-the-components-dom"></span>
          Finding elements in the component&#39;s DOM
        </h4>
      <p>Each instance of a <code>ComponentHarness</code> subclass represents a particular instance of the
corresponding component. You can access the component&#39;s host element via the <code>host</code> method from
the <code>ComponentHarness</code> base class.</p>
<p><code>ComponentHarness</code> additionally offers several methods for locating elements within the component&#39;s
DOM. These methods are <code>locatorFor</code>, <code>locatorForOptional</code>, and <code>locatorForAll</code>.
Note, though, that these methods do not directly find elements. Instead, they <em>create functions</em>
that find elements. This approach safeguards against caching references to out-of-date elements. For
example, when an <code>ngIf</code> hides and then shows an element, the result is a new DOM element; using
functions ensures that tests always reference the current state of the DOM.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>host(): Promise&lt;TestElement&gt;</code></td>
<td>Returns a <code>Promise</code> for the host element of the corresponding component instance.</td>
</tr>
<tr>
<td><code>locatorFor(selector: string): () =&gt; Promise&lt;TestElement&gt;</code></td>
<td>Creates a function that returns a <code>Promise</code> for the first element matching the given selector when called. If no matching element is found, the <code>Promise</code> rejects.</td>
</tr>
<tr>
<td><code>locatorForOptional(selector: string): () =&gt; Promise&lt;TestElement | null&gt;</code></td>
<td>Creates a function that returns a <code>Promise</code> for the first element matching the given selector when called. If no matching element is found, the <code>Promise</code> is resolved with <code>null</code>.</td>
</tr>
<tr>
<td><code>locatorForAll(selector: string): () =&gt; Promise&lt;TestElement[]&gt;</code></td>
<td>Creates a function that returns a <code>Promise</code> for a list of all elements matching the given selector when called.</td>
</tr>
</tbody></table>
<p>For example, the <code>MyPopupHarness</code> class discussed above could provide methods to get the trigger
and content elements as follows:</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-popup&#x27;</span>;

  <span class="hljs-comment">/** Gets the trigger element */</span>
  getTriggerElement = <span class="hljs-built_in">this</span>.locatorFor(<span class="hljs-string">&#x27;button&#x27;</span>);

  <span class="hljs-comment">/** Gets the content element. */</span>
  getContentElement = <span class="hljs-built_in">this</span>.locatorForOptional(<span class="hljs-string">&#x27;.my-popup-content&#x27;</span>);
}
</code></pre>

        <h4 id="working-with-testelement-instances" class="docs-header-link">
          <span header-link="working-with-testelement-instances"></span>
          Working with <code>TestElement</code> instances
        </h4>
      <p>The functions created with the locator methods described above all return <code>TestElement</code> instances.
<code>TestElement</code> offers a number of methods to interact with the underlying DOM:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>blur(): Promise&lt;void&gt;</code></td>
<td>Blurs the element.</td>
</tr>
<tr>
<td><code>clear(): Promise&lt;void&gt;</code></td>
<td>Clears the text in the element (intended for <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> only).</td>
</tr>
<tr>
<td><code>click(relativeX?: number, relativeY?: number): Promise&lt;void&gt;</code></td>
<td>Clicks the element (at the given position relative to the element&#39;s top-left corner).</td>
</tr>
<tr>
<td><code>focus(): Promise&lt;void&gt;</code></td>
<td>Focuses the element.</td>
</tr>
<tr>
<td><code>getCssValue(property: string): Promise&lt;string&gt;</code></td>
<td>Gets the computed value of the given CSS property for the element.</td>
</tr>
<tr>
<td><code>hover(): Promise&lt;void&gt;</code></td>
<td>Hovers over the element.</td>
</tr>
<tr>
<td><code>sendKeys(modifiers?: ModifierKeys, ...keys: (string | TestKey)[]): Promise&lt;void&gt;</code></td>
<td>Sends the given list of key presses to the element (with optional modifier keys).</td>
</tr>
<tr>
<td><code>text(): Promise&lt;string&gt;</code></td>
<td>Gets the text content of the element</td>
</tr>
<tr>
<td><code>getAttribute(name: string): Promise&lt;string | null&gt;</code></td>
<td>Gets the value of the given HTML attribute for the element.</td>
</tr>
<tr>
<td><code>hasClass(name: string): Promise&lt;boolean&gt;</code></td>
<td>Checks whether the element has the given class applied.</td>
</tr>
<tr>
<td><code>getDimensions(): Promise&lt;ElementDimensions&gt;</code></td>
<td>Gets the dimensions of the element.</td>
</tr>
<tr>
<td><code>getProperty(name: string): Promise&lt;any&gt;</code></td>
<td>Gets the value of the given JS property for the element.</td>
</tr>
<tr>
<td><code>matchesSelector(selector: string): Promise&lt;boolean&gt;</code></td>
<td>Checks whether the element matches the given CSS selector.</td>
</tr>
<tr>
<td><code>setInputValue(value: string): Promise&lt;void&gt;;</code></td>
<td>Sets the value of a property of an input.</td>
</tr>
<tr>
<td><code>selectOptions(...optionIndexes: number[]): Promise&lt;void&gt;;</code></td>
<td>Selects the options at the specified indexes inside of a native <code>select</code> element.</td>
</tr>
<tr>
<td><code>dispatchEvent(name: string, data?: Record&lt;string, EventData&gt;): Promise&lt;void&gt;;</code></td>
<td>Dispatches an event with a particular name.</td>
</tr>
</tbody></table>
<p><code>TestElement</code> is an abstraction designed to work across different test environments (Karma,
Selenium WebDriver, etc). When using harnesses, you should perform all DOM interaction via this interface.
Other means of accessing DOM elements (e.g. <code>document.querySelector</code>) will not work in all test
environments.</p>
<p>As a best practice, you should not expose <code>TestElement</code> instances to users of a harness
unless its an element the component consumer defines directly (e.g. the host element). Exposing
<code>TestElement</code> instances for internal elements leads users to depend on a component&#39;s internal DOM
structure.</p>
<p>Instead, provide more narrow-focused methods for particular actions the end-user will
take or particular state they may want to check. For example, <code>MyPopupHarness</code> could provide methods
like <code>toggle</code> and <code>isOpen</code>:</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-popup&#x27;</span>;

  <span class="hljs-keyword">protected</span> getTriggerElement = <span class="hljs-built_in">this</span>.locatorFor(<span class="hljs-string">&#x27;button&#x27;</span>);
  <span class="hljs-keyword">protected</span> getContentElement = <span class="hljs-built_in">this</span>.locatorForOptional(<span class="hljs-string">&#x27;.my-popup-content&#x27;</span>);

  <span class="hljs-comment">/** Toggles the open state of the popup. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> trigger = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getTriggerElement();
    <span class="hljs-keyword">return</span> trigger.click();
  }

  <span class="hljs-comment">/** Checks if the popup us open. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">isOpen</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getContentElement();
    <span class="hljs-keyword">return</span> !!content;
  }
}
</code></pre>

        <h4 id="loading-harnesses-for-subcomponents" class="docs-header-link">
          <span header-link="loading-harnesses-for-subcomponents"></span>
          Loading harnesses for subcomponents
        </h4>
      <p>Larger components often compose smaller components. You can reflect this structure in a
component&#39;s harness as well. Each of the <code>locatorFor</code> methods on <code>ComponentHarness</code> discussed
earlier has an alternate signature that can be used for locating sub-harnesses rather than elements.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>locatorFor&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T&gt;</code></td>
<td>Creates a function that returns a <code>Promise</code> for the first harness matching the given harness type when called. If no matching harness is found, the <code>Promise</code> rejects.</td>
</tr>
<tr>
<td><code>locatorForOptional&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T | null&gt;</code></td>
<td>Creates a function that returns a <code>Promise</code> for the first harness matching the given harness type when called. If no matching harness is found, the <code>Promise</code> is resolved with <code>null</code>.</td>
</tr>
<tr>
<td><code>locatorForAll&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T[]&gt;</code></td>
<td>Creates a function that returns a <code>Promise</code> for a list of all harnesses matching the given harness type when called.</td>
</tr>
</tbody></table>
<p>For example, consider a menu build using the popup shown above:</p>
<pre><code class="language-ts"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;my-menu&#x27;</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;my-popup&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/my-popup&gt;
  `</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenu</span> </span>{
  <span class="hljs-meta">@Input</span>() triggerText: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@ContentChildren</span>(MyMenuItem) items: QueryList&lt;MyMenuItem&gt;;
}

<span class="hljs-meta">@Directive</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;my-menu-item&#x27;</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItem</span> </span>{}
</code></pre>
<p>The harness for <code>MyMenu</code> can then take advantage of other harnesses for <code>MyPopup</code> and <code>MyMenuItem</code>:</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-menu&#x27;</span>;

  <span class="hljs-keyword">protected</span> getPopupHarness = <span class="hljs-built_in">this</span>.locatorFor(MyPopupHarness);

  <span class="hljs-comment">/** Gets the currently shown menu items (empty list if menu is closed). */</span>
  getItems = <span class="hljs-built_in">this</span>.locatorForAll(MyMenuItemHarness);

  <span class="hljs-comment">/** Toggles open state of the menu. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> popupHarness = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPopupHarness();
    <span class="hljs-keyword">return</span> popupHarness.toggle();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItemHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-menu-item&#x27;</span>;
}
</code></pre>

        <h4 id="filtering-harness-instances-with-harnesspredicate" class="docs-header-link">
          <span header-link="filtering-harness-instances-with-harnesspredicate"></span>
          Filtering harness instances with <code>HarnessPredicate</code>
        </h4>
      <p>When a page contains multiple instances of a particular component, you may want to filter based on
some property of the component to get a particular component instance. For example, you may want
a button with some specific text, or a menu with a specific ID. The <code>HarnessPredicate</code>
class can capture criteria like this for a <code>ComponentHarness</code> subclass. While the
test author is able to construct <code>HarnessPredicate</code> instances manually, it&#39;s easier when the
<code>ComponentHarness</code> subclass provides a helper method to construct predicates for common filters.</p>
<p>The recommended approach to providing this helper is to create a static <code>with</code> method on each
<code>ComponentHarness</code> subclass that returns a <code>HarnessPredicate</code> for that class. This allows test
authors to write easily understandable code, e.g.
<code>loader.getHarness(MyMenuHarness.with({selector: &#39;#menu1&#39;}))</code>. In addition to the standard
<code>selector</code> and <code>ancestor</code> options, the <code>with</code> method should add any other options that make sense
for the particular subclass.</p>
<p>Harnesses that need to add additional options should extend the <code>BaseHarnessFilters</code> interface and
additional optional properties as needed. <code>HarnessPredicate</code> provides several convenience methods
for adding options.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>static stringMatches(s: string | Promise&lt;string&gt;, pattern: string | RegExp): Promise&lt;boolean&gt;</code></td>
<td>Compares a string or <code>Promise</code> of a string against a <code>string</code> or <code>RegExp</code> and returns a boolean <code>Promise</code> indicating whether it matches.</td>
</tr>
<tr>
<td><code>addOption&lt;O&gt;(name: string, option: O | undefined, predicate: (harness: T, option: O) =&gt; Promise&lt;boolean&gt;): HarnessPredicate&lt;T&gt;</code></td>
<td>Creates a new <code>HarnessPredicate</code> that enforces all of the conditions of the current one, plus the new constraint specified by the <code>predicate</code> parameter. If the <code>option</code> parameter is <code>undefined</code> the <code>predicate</code> is considered to be always true.</td>
</tr>
<tr>
<td><code>add(description: string, predicate: (harness: T) =&gt; Promise&lt;boolean&gt;): HarnessPredicate&lt;T&gt;</code></td>
<td>Creates a new <code>HarnessPredicate</code> that enforces all of the conditions of the current one, plus the new constraint specified by the <code>predicate</code> parameter.</td>
</tr>
</tbody></table>
<p>For example, when working with a menu it would likely be useful to add a way to filter based on
trigger text and to filter menu items based on their text:</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> MyMenuHarnessFilters <span class="hljs-keyword">extends</span> BaseHarnessFilters {
  <span class="hljs-comment">/** Filters based on the trigger text for the menu. */</span>
  triggerText?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">RegExp</span>;
}

<span class="hljs-keyword">interface</span> MyMenuItemHarnessFilters <span class="hljs-keyword">extends</span> BaseHarnessFilters {
  <span class="hljs-comment">/** Filters based on the text of the menu item. */</span>
  text?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">RegExp</span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-menu&#x27;</span>;

  <span class="hljs-comment">/** Creates a `HarnessPredicate` used to locate a particular `MyMenuHarness`. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">with</span>(options: MyMenuHarnessFilters): HarnessPredicate&lt;MyMenuHarness&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HarnessPredicate(MyMenuHarness, options)
        .addOption(<span class="hljs-string">&#x27;trigger text&#x27;</span>, options.triggerText,
            <span class="hljs-function">(<span class="hljs-params">harness, text</span>) =&gt;</span> HarnessPredicate.stringMatches(harness.getTriggerText(), text));
  }

  <span class="hljs-keyword">protected</span> getPopupHarness = <span class="hljs-built_in">this</span>.locatorFor(MyPopupHarness);

  <span class="hljs-comment">/** Gets the text of the menu trigger. */</span>
  <span class="hljs-keyword">async</span> getTriggerText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> popupHarness = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPopupHarness();
    <span class="hljs-keyword">return</span> popupHarness.getTriggerText();
  }

  ...
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItemHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-menu-item&#x27;</span>;

  <span class="hljs-comment">/** Creates a `HarnessPredicate` used to locate a particular `MyMenuItemHarness`. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">with</span>(options: MyMenuItemHarnessFilters): HarnessPredicate&lt;MyMenuItemHarness&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HarnessPredicate(MyMenuItemHarness, options)
        .addOption(<span class="hljs-string">&#x27;text&#x27;</span>, options.text,
            <span class="hljs-function">(<span class="hljs-params">harness, text</span>) =&gt;</span> HarnessPredicate.stringMatches(harness.getText(), text));
  }

  <span class="hljs-comment">/** Gets the text of the menu item. */</span>
  <span class="hljs-keyword">async</span> getText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> host = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.host();
    <span class="hljs-keyword">return</span> host.text();
  }
}
</code></pre>
<p>You can pass a <code>HarnessPredicate</code> in place of a <code>ComponentHarness</code> class to any of the APIs on
<code>HarnessLoader</code>, <code>LocatorFactory</code>, or <code>ComponentHarness</code>. This allows test authors to easily target
a particular component instance when creating a harness instance. It also allows the harness author
to leverage the same <code>HarnessPredicate</code> to enable more powerful APIs on their harness class. For
example, consider the <code>getItems</code> method on the <code>MyMenuHarness</code> shown above.
This can now easily be expanded to allow users of the harness to search for particular menu items:</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-menu&#x27;</span>;

  <span class="hljs-comment">/** Gets a list of items in the menu, optionally filtered based on the given criteria. */</span>
  <span class="hljs-keyword">async</span> getItems(filters: MyMenuItemHarnessFilters = {}): <span class="hljs-built_in">Promise</span>&lt;MyMenuItemHarness[]&gt; {
    <span class="hljs-keyword">const</span> getFilteredItems = <span class="hljs-built_in">this</span>.locatorForAll(MyMenuItemHarness.with(filters));
    <span class="hljs-keyword">return</span> getFilteredItems();
  }

  ...
}
</code></pre>

        <h4 id="creating-a-harnessloader-for-an-element" class="docs-header-link">
          <span header-link="creating-a-harnessloader-for-an-element"></span>
          Creating a <code>HarnessLoader</code> for an element
        </h4>
      <p>Some components use <code>&lt;ng-content&gt;</code> to project additional content into the component&#39;s template. When
creating a harness for such a component, you can give the harness user a <code>HarnessLoader</code> instance
scoped to the element containing the <code>&lt;ng-content&gt;</code>. This allows the user of the harness to load
additional harnesses for whatever components were passed in as content. <code>ComponentHarness</code> has
several APIs that can be used to create <code>HarnessLoader</code> instances for cases like this.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>harnessLoaderFor(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td>Gets a <code>Promise</code> for a <code>HarnessLoader</code> rooted at the first element matching the given selector, if no element is found the <code>Promise</code> rejects.</td>
</tr>
<tr>
<td><code>harnessLoaderForOptional(selector: string): Promise&lt;HarnessLoader | null&gt;</code></td>
<td>Gets a <code>Promise</code> for a <code>HarnessLoader</code> rooted at the first element matching the given selector, if no element is found the <code>Promise</code> resolves to <code>null</code>.</td>
</tr>
<tr>
<td><code>harnessLoaderForAll(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td>Gets a <code>Promise</code> for a list of <code>HarnessLoader</code>, one rooted at each element matching the given selector.</td>
</tr>
</tbody></table>
<p>The <code>MyPopup</code> component discussed earlier is a good example of a component with arbitrary content
that users may want to load harnesses for. <code>MyPopupHarness</code> could add support for this by
extending <code>ContentContainerComponentHarness</code>.</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentContainerComponentHarness</span>&lt;<span class="hljs-title">string</span>&gt; </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-popup&#x27;</span>;
}
</code></pre>

        <h4 id="accessing-elements-outside-of-the-components-host-element" class="docs-header-link">
          <span header-link="accessing-elements-outside-of-the-components-host-element"></span>
          Accessing elements outside of the component&#39;s host element
        </h4>
      <p>There are times when a component harness might need to access elements outside of its corresponding
component&#39;s host element. Components that use <a href="https://material.angular.io/cdk/overlay/overview">CDK overlay</a> serve as examples of this. The CDK overlay creates an element that is attached directly to the body, outside of the component&#39;s host element. In this case,
<code>ComponentHarness</code> provides a method that can be used to get a <code>LocatorFactory</code> for the root element
of the document. The <code>LocatorFactory</code> supports most of the same APIs as the <code>ComponentHarness</code> base
class, and can then be used to query relative to the document&#39;s root element.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>documentRootLocatorFactory(): LocatorFactory</code></td>
<td>Creates a <code>LocatorFactory</code> rooted at the document&#39;s root element.</td>
</tr>
</tbody></table>
<p>Consider if the <code>MyPopup</code> component above used the CDK overlay for the popup content, rather than an
element in its own template. In this case, <code>MyPopupHarness</code> would have to access the content element
via <code>documentRootLocatorFactory()</code>:</p>
<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">&#x27;my-popup&#x27;</span>;

  <span class="hljs-comment">/** Gets a `HarnessLoader` whose root element is the popup&#x27;s content element. */</span>
  <span class="hljs-keyword">async</span> getHarnessLoaderForContent(): <span class="hljs-built_in">Promise</span>&lt;HarnessLoader&gt; {
    <span class="hljs-keyword">const</span> rootLocator = <span class="hljs-built_in">this</span>.documentRootLocatorFactory();
    <span class="hljs-keyword">return</span> rootLocator.harnessLoaderFor(<span class="hljs-string">&#x27;my-popup-content&#x27;</span>);
  }
}
</code></pre>

        <h4 id="waiting-for-asynchronous-tasks" class="docs-header-link">
          <span header-link="waiting-for-asynchronous-tasks"></span>
          Waiting for asynchronous tasks
        </h4>
      <p>The methods on <code>TestElement</code> automatically trigger Angular&#39;s change detection and wait for tasks
inside the <code>NgZone</code>, so in most cases no special effort is required for harness authors to wait on
asynchronous tasks. However, there are some edge cases where this may not be sufficient.</p>
<p>Under some circumstances, Angular animations may require a second cycle of change detection and
subsequent <code>NgZone</code> stabilization before animation events are fully flushed. In cases where this is
needed, the <code>ComponentHarness</code> offers a <code>forceStabilize()</code> method that can be called to do the
second round.</p>
<p>Additionally, some components may intentionally schedule tasks <em>outside</em> of <code>NgZone</code>, this is
typically accomplished by using <code>NgZone.runOutsideAngular</code>. In this case, the corresponding harness
may need to explicitly wait for tasks outside <code>NgZone</code>, as this does not happen automatically.
<code>ComponentHarness</code> offers a method called <code>waitForTasksOutsideAngular</code> for this purpose.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>forceStabilize(): Promise&lt;void&gt;</code></td>
<td>Explicitly runs a round of change detection in Angular and waits for <code>NgZone</code> to stabilize.</td>
</tr>
<tr>
<td><code>waitForTasksOutsideAngular(): Promise&lt;void&gt;</code></td>
<td>Waits for tasks scheduled outside of <code>NgZone</code> to complete.</td>
</tr>
</tbody></table>

        <h3 id="api-for-harness-environment-authors" class="docs-header-link">
          <span header-link="api-for-harness-environment-authors"></span>
          API for harness environment authors
        </h3>
      <p>Harness environment authors are developers who want to add support for using component harnesses in
additional testing environments. Out-of-the-box, Angular CDK&#39;s component harnesses can be used in
Selenium WebDriver E2E tests and Karma unit tests. Developers can support additional environments by
creating custom implementations of <code>TestElement</code> and <code>HarnessEnvironment</code>.</p>

        <h4 id="creating-a-testelement-implementation-for-the-environment" class="docs-header-link">
          <span header-link="creating-a-testelement-implementation-for-the-environment"></span>
          Creating a <code>TestElement</code> implementation for the environment
        </h4>
      <p>The first step in adding support for a new testing environment is to create a <code>TestElement</code>
implementation. The <code>TestElement</code> interface serves as an environment-agnostic representation of a
DOM element; it lets harnesses interact with DOM elements regardless of the underlying environment.
Because some environments don&#39;t support interacting with DOM elements synchronously
(e.g. WebDriver), all of the <code>TestElement</code> methods are asynchronous, returning a <code>Promise</code> with the
result of the operation.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>blur(): Promise&lt;void&gt;</code></td>
<td>Blurs the element.</td>
</tr>
<tr>
<td><code>clear(): Promise&lt;void&gt;</code></td>
<td>Clears the text from an element (only applies for <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code>).</td>
</tr>
<tr>
<td><code>click(relativeX?: number, relativeY?: number): Promise&lt;void&gt;</code></td>
<td>Clicks an element at a point relative to it&#39;s top-left corner.</td>
</tr>
<tr>
<td><code>focus(): Promise&lt;void&gt;</code></td>
<td>Focuses the element.</td>
</tr>
<tr>
<td><code>getCssValue(property: string): Promise&lt;string&gt;</code></td>
<td>Gets the computed CSS value of the given property for the element.</td>
</tr>
<tr>
<td><code>hover(): Promise&lt;void&gt;</code></td>
<td>Hovers the mouse over the element.</td>
</tr>
<tr>
<td><code>sendKeys(...keys: (string | TestKey)[]): Promise&lt;void&gt;</code></td>
<td>Sends a sequence of key events to the element.</td>
</tr>
<tr>
<td><code>sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise&lt;void&gt;</code></td>
<td>Sends a sequence of key events to the element, while holding a set of modifier keys.</td>
</tr>
<tr>
<td><code>text(): Promise&lt;string&gt;</code></td>
<td>Gets the text content of the element.</td>
</tr>
<tr>
<td><code>getAttribute(name: string): Promise&lt;string | null&gt;</code></td>
<td>Gets the value of the given HTML attribute for the element.</td>
</tr>
<tr>
<td><code>hasClass(name: string): Promise&lt;boolean&gt;</code></td>
<td>Checks whether the element has the given class.</td>
</tr>
<tr>
<td><code>getDimensions(): Promise&lt;ElementDimensions&gt;</code></td>
<td>Gets the dimensions of the element.</td>
</tr>
<tr>
<td><code>getProperty(name: string): Promise&lt;any&gt;</code></td>
<td>Gets the value of the given property for the element.</td>
</tr>
<tr>
<td><code>matchesSelector(selector: string): Promise&lt;boolean&gt;</code></td>
<td>Checks whether the given selector matches the element.</td>
</tr>
<tr>
<td><code>setInputValue(value: string): Promise&lt;void&gt;;</code></td>
<td>Sets the value of a property of an input.</td>
</tr>
<tr>
<td><code>selectOptions(...optionIndexes: number[]): Promise&lt;void&gt;;</code></td>
<td>Selects the options at the specified indexes inside of a native <code>select</code> element.</td>
</tr>
<tr>
<td><code>dispatchEvent(name: string, data?: Record&lt;string, EventData&gt;): Promise&lt;void&gt;;</code></td>
<td>Dispatches an event with a particular name.</td>
</tr>
</tbody></table>
<p>The <code>TestElement</code> interface consists largely of methods that resemble methods
available on <code>HTMLElement</code>; similar methods exist in most test environments, which makes
implementing the methods fairly straightforward. However, one important difference to note when
implementing the <code>sendKeys</code> method, is that the key codes in the <code>TestKey</code>
enum likely differ from the key codes used in the test environment. Environment authors should
maintain a mapping from <code>TestKey</code> codes to the codes used in the particular testing environment.</p>
<p>The
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/testbed/unit-test-element.ts#L57"><code>UnitTestElement</code></a>
and
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-element.ts#L22"><code>SeleniumWebDriverElement</code></a>
implementations in Angular CDK serve as good examples of implementations of this interface.</p>

        <h4 id="creating-a-harnessenvironment-implementation-for-the-environment" class="docs-header-link">
          <span header-link="creating-a-harnessenvironment-implementation-for-the-environment"></span>
          Creating a <code>HarnessEnvironment</code> implementation for the environment
        </h4>
      <p>Test authors use <code>HarnessEnvironment</code> to create component harness instances for use in tests.</p>
<p><code>HarnessEnvironment</code> is an abstract class that must be extended to create a concrete subclass for
the new environment. When supporting a new test environment, you must create a <code>HarnessEnvironment</code>
subclass that adds concrete implementations for all abstract members.</p>
<p>You will notice that <code>HarnessEnvironment</code> has a generic type parameter: <code>HarnessEnvironment&lt;E&gt;</code>.
This parameter, <code>E</code>, represents the raw element type of the environment. For example, this parameter
is <code>Element</code> for unit test environments.</p>
<p>The following are the abstract methods that must be implemented:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>abstract getDocumentRoot(): E</code></td>
<td>Gets the root element for the environment (e.g. <code>document.body</code>).</td>
</tr>
<tr>
<td><code>abstract createTestElement(element: E): TestElement</code></td>
<td>Creates a <code>TestElement</code> for the given raw element.</td>
</tr>
<tr>
<td><code>abstract createEnvironment(element: E): HarnessEnvironment</code></td>
<td>Creates a <code>HarnessEnvironment</code> rooted at the given raw element.</td>
</tr>
<tr>
<td><code>abstract getAllRawElements(selector: string): Promise&lt;E[]&gt;</code></td>
<td>Gets all of the raw elements under the root element of the environment matching the given selector.</td>
</tr>
<tr>
<td><code>abstract forceStabilize(): Promise&lt;void&gt;</code></td>
<td>Gets a <code>Promise</code> that resolves when the <code>NgZone</code> is stable. Additionally, if applicable, tells <code>NgZone</code> to stabilize (e.g. calling <code>flush()</code> in a <code>fakeAsync</code> test).</td>
</tr>
<tr>
<td><code>abstract waitForTasksOutsideAngular(): Promise&lt;void&gt;</code></td>
<td>Gets a <code>Promise</code> that resolves when the parent zone of <code>NgZone</code> is stable.</td>
</tr>
</tbody></table>
<p>In addition to implementing the missing methods, this class should provide a way for test authors to
get <code>ComponentHarness</code> instances. The recommended approach is to have a protected constructor and
provide a static method called <code>loader</code> that returns a <code>HarnessLoader</code> instance. This allows test
authors to write code like: <code>SomeHarnessEnvironment.loader().getHarness(...)</code>. Depending on the
needs of the particular environment, the class may provide several different static methods or
require arguments to be passed. (e.g. the <code>loader</code> method on <code>TestbedHarnessEnvironment</code> takes a
<code>ComponentFixture</code>, and the class provides additional static methods called <code>documentRootLoader</code> and
<code>harnessForFixture</code>).</p>
<p>The
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/testbed/testbed-harness-environment.ts#L20"><code>TestbedHarnessEnvironment</code></a>
and
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-harness-environment.ts#L71"><code>SeleniumWebDriverHarnessEnvironment</code></a>
implementations in Angular CDK serve as good examples of implementations of this interface.</p>

        <h4 id="handling-auto-change-detection-status" class="docs-header-link">
          <span header-link="handling-auto-change-detection-status"></span>
          Handling auto change detection status
        </h4>
      <p>In order to support the <code>manualChangeDetection</code> and <code>parallel</code> APIs, your environment should install
a handler for the auto change detection status.</p>
<p>When your environment wants to start handling the auto change detection status it can call
<code>handleAutoChangeDetectionStatus(handler)</code>. The handler function will receive a 
<code>AutoChangeDetectionStatus</code> which has two properties:</p>
<ul>
<li><code>isDisabled: boolean</code> - Indicates whether auto change detection is currently disabled. When true,
your environment&#39;s <code>forceStabilize</code> method should act as a no-op. This allows users to trigger
change detection manually instead.</li>
<li><code>onDetectChangesNow?: () =&gt; void</code> - If this optional callback is specified, your environment
should trigger change detection immediately and call the callback when change detection finishes.</li>
</ul>
<p>If your environment wants to stop handling auto change detection status it can call
<code>stopHandlingAutoChangeDetectionStatus()</code>.</p>
</div>